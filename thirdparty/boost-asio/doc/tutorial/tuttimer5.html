<HTML>
  <HEAD>
    <TITLE>asio Tutorial: Timer.5 - Synchronising handlers in multithreaded programs</TITLE>
    <LINK HREF="asio.css" REL="stylesheet" TYPE="text/css">
    <LINK HREF="tabs.css" REL="stylesheet" TYPE="text/css">
  </HEAD>
  <BODY BGCOLOR="#FFFFFF">
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.7</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>Tutorial</B>
          </TD>
        </TR>
      </TABLE>
    </DIV>
<!-- Generated by Doxygen 1.4.7 -->
<h1><a class="anchor" name="tuttimer5">Timer.5 - Synchronising handlers in multithreaded programs</a></h1>This tutorial demonstrates the use of the <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00262.html#6b7ed9dbdc34fb690ffd6a01ef015c22">asio::strand</a> class to synchronise callback handlers in a multithreaded program.<p>
The previous four tutorials avoided the issue of handler synchronisation by calling the <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00140.html#50ae7753f2c851cd3e91724bbfc5b444">asio::io_service::run()</a> function from one thread only. As you already know, the asio library provides a guarantee that callback handlers will <b>only</b> be called from threads that are currently calling <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00140.html#50ae7753f2c851cd3e91724bbfc5b444">asio::io_service::run()</a>. Consequently, calling <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00140.html#50ae7753f2c851cd3e91724bbfc5b444">asio::io_service::run()</a> from only one thread ensures that callback handlers cannot run concurrently.<p>
The single threaded approach is usually the best place to start when developing applications using asio. The downside is the limitations it places on programs, particularly servers, including:<p>
<ul>
<li>
Poor responsiveness when handlers can take a long time to complete. </li>
<li>
An inability to scale on multiprocessor systems. </li>
</ul>
<p>
If you find yourself running into these limitations, an alternative approach is to have a pool of threads calling <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00140.html#50ae7753f2c851cd3e91724bbfc5b444">asio::io_service::run()</a>. However, as this allows handlers to execute concurrently, we need a method of synchronisation when handlers might be accessing a shared, thread-unsafe resource.<p>
<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;asio.hpp&gt;</span>
<span class="preprocessor">#include &lt;boost/bind.hpp&gt;</span>
<span class="preprocessor">#include &lt;boost/date_time/posix_time/posix_time.hpp&gt;</span>
</pre></div><p>
We start by defining a class called <code>printer</code>, similar to the class in the previous tutorial. This class will extend the previous tutorial by running two timers in parallel.<p>
<div class="fragment"><pre class="fragment">
<span class="keyword">class </span>printer
{
<span class="keyword">public</span>:
</pre></div><p>
In addition to initialising a pair of <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00262.html#9c1e57628983c6b9c45e9204228109b7">asio::deadline_timer</a> members, the constructor initialises the <code>strand_</code> member, an object of type <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00262.html#6b7ed9dbdc34fb690ffd6a01ef015c22">asio::strand</a>.<p>
An <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00262.html#6b7ed9dbdc34fb690ffd6a01ef015c22">asio::strand</a> guarantees that, for those handlers that are dispatched through it, an executing handler will be allowed to complete before the next one is started. This is guaranteed irrespective of the number of threads that are calling <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00140.html#50ae7753f2c851cd3e91724bbfc5b444">asio::io_service::run()</a>. Of course, the handlers may still execute concurrently with other handlers that were <b>not</b> dispatched through an <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00262.html#6b7ed9dbdc34fb690ffd6a01ef015c22">asio::strand</a>, or were dispatched through a different <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00262.html#6b7ed9dbdc34fb690ffd6a01ef015c22">asio::strand</a> object.<p>
<div class="fragment"><pre class="fragment">  printer(<a class="codeRef" doxygen="asio.doxytags:../reference/" href="../reference/a00140.html">asio::io_service</a>&amp; io)
    : strand_(io),
      timer1_(io, boost::posix_time::seconds(1)),
      timer2_(io, boost::posix_time::seconds(1)),
      count_(0)
  {
</pre></div><p>
When initiating the asynchronous operations, each callback handler is "wrapped" using the <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00262.html#6b7ed9dbdc34fb690ffd6a01ef015c22">asio::strand</a> object. The <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00117.html#84c19020e0b4d2dcee114d27566bced2">asio::strand::wrap()</a> function returns a new handler that automatically dispatches its contained handler through the <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00262.html#6b7ed9dbdc34fb690ffd6a01ef015c22">asio::strand</a> object. By wrapping the handlers using the same <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00262.html#6b7ed9dbdc34fb690ffd6a01ef015c22">asio::strand</a>, we are ensuring that they cannot execute concurrently.<p>
<div class="fragment"><pre class="fragment">    timer1_.async_wait(strand_.wrap(boost::bind(&amp;printer::print1, <span class="keyword">this</span>)));
    timer2_.async_wait(strand_.wrap(boost::bind(&amp;printer::print2, <span class="keyword">this</span>)));
  }

  ~printer()
  {
    std::cout &lt;&lt; <span class="stringliteral">"Final count is "</span> &lt;&lt; count_ &lt;&lt; <span class="stringliteral">"\n"</span>;
  }
</pre></div><p>
In a multithreaded program, the handlers for asynchronous operations should be synchronised if they access shared resources. In this tutorial, the shared resources used by the handlers (<code>print1</code> and <code>print2</code>) are <code>std::cout</code> and the <code>count_</code> data member.<p>
<div class="fragment"><pre class="fragment">
  <span class="keywordtype">void</span> print1()
  {
    <span class="keywordflow">if</span> (count_ &lt; 10)
    {
      std::cout &lt;&lt; <span class="stringliteral">"Timer 1: "</span> &lt;&lt; count_ &lt;&lt; <span class="stringliteral">"\n"</span>;
      ++count_;

      timer1_.expires_at(timer1_.expires_at() + boost::posix_time::seconds(1));
      timer1_.async_wait(strand_.wrap(boost::bind(&amp;printer::print1, <span class="keyword">this</span>)));
    }
  }

  <span class="keywordtype">void</span> print2()
  {
    <span class="keywordflow">if</span> (count_ &lt; 10)
    {
      std::cout &lt;&lt; <span class="stringliteral">"Timer 2: "</span> &lt;&lt; count_ &lt;&lt; <span class="stringliteral">"\n"</span>;
      ++count_;

      timer2_.expires_at(timer2_.expires_at() + boost::posix_time::seconds(1));
      timer2_.async_wait(strand_.wrap(boost::bind(&amp;printer::print2, <span class="keyword">this</span>)));
    }
  }

<span class="keyword">private</span>:
  <a class="codeRef" doxygen="asio.doxytags:../reference/" href="../reference/a00117.html">asio::strand</a> strand_;
  <a class="codeRef" doxygen="asio.doxytags:../reference/" href="../reference/a00106.html">asio::deadline_timer</a> timer1_;
  <a class="codeRef" doxygen="asio.doxytags:../reference/" href="../reference/a00106.html">asio::deadline_timer</a> timer2_;
  <span class="keywordtype">int</span> count_;
};
</pre></div><p>
The <code>main</code> function now causes <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00140.html#50ae7753f2c851cd3e91724bbfc5b444">asio::io_service::run()</a> to be called from two threads: the main thread and one additional thread. This is accomplished using an <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00169.html">asio::thread</a> object.<p>
Just as it would with a call from a single thread, concurrent calls to <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00140.html#50ae7753f2c851cd3e91724bbfc5b444">asio::io_service::run()</a> will continue to execute while there is "work" left to do. The background thread will not exit until all asynchronous operations have completed.<p>
<div class="fragment"><pre class="fragment">
<span class="keywordtype">int</span> main()
{
  <a class="codeRef" doxygen="asio.doxytags:../reference/" href="../reference/a00140.html">asio::io_service</a> io;
  printer p(io);
  <a class="codeRef" doxygen="asio.doxytags:../reference/" href="../reference/a00169.html">asio::thread</a> t(boost::bind(&amp;<a class="codeRef" doxygen="asio.doxytags:../reference/" href="../reference/a00140.html#50ae7753f2c851cd3e91724bbfc5b444">asio::io_service::run</a>, &amp;io));
  io.<a class="codeRef" doxygen="asio.doxytags:../reference/" href="../reference/a00140.html#50ae7753f2c851cd3e91724bbfc5b444">run</a>();
  t.join();

  <span class="keywordflow">return</span> 0;
}
</pre></div><p>
See the <a class="el" href="tuttimer5src.html">full source listing</a> <br>
 Return to the <a class="el" href="index.html#index">tutorial index</a> <br>
 Previous: <a class="el" href="tuttimer4.html">Timer.4 - Using a member function as a handler</a> <br>
     <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.7</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
  </BODY>
</HTML>
