<HTML>
  <HEAD>
    <TITLE>asio Tutorial: Timer.2 - Using a timer asynchronously</TITLE>
    <LINK HREF="asio.css" REL="stylesheet" TYPE="text/css">
    <LINK HREF="tabs.css" REL="stylesheet" TYPE="text/css">
  </HEAD>
  <BODY BGCOLOR="#FFFFFF">
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.7</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>Tutorial</B>
          </TD>
        </TR>
      </TABLE>
    </DIV>
<!-- Generated by Doxygen 1.4.7 -->
<h1><a class="anchor" name="tuttimer2">Timer.2 - Using a timer asynchronously</a></h1>This tutorial program demonstrates how to use asio's asynchronous callback functionality by modifying the program from tutorial Timer.1 to perform an asynchronous wait on the timer.<p>
<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;asio.hpp&gt;</span>
<span class="preprocessor">#include &lt;boost/date_time/posix_time/posix_time.hpp&gt;</span>
</pre></div><p>
Using asio's asynchronous functionality means having a callback function that will be called when an asynchronous operation completes. In this program we define a function called <code>print</code> to be called when the asynchronous wait finishes.<p>
<div class="fragment"><pre class="fragment">
<span class="keywordtype">void</span> print(<span class="keyword">const</span> <a class="codeRef" doxygen="asio.doxytags:../reference/" href="../reference/a00135.html">asio::error</a>&amp; <span class="comment">/*e*/</span>)
{
  std::cout &lt;&lt; <span class="stringliteral">"Hello, world!\n"</span>;
}

<span class="keywordtype">int</span> main()
{
  <a class="codeRef" doxygen="asio.doxytags:../reference/" href="../reference/a00140.html">asio::io_service</a> io;

  <a class="codeRef" doxygen="asio.doxytags:../reference/" href="../reference/a00106.html">asio::deadline_timer</a> t(io, boost::posix_time::seconds(5));
</pre></div><p>
Next, instead of doing a blocking wait as in tutorial Timer.1, we call the <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00106.html#2ad7fdf0eb7a53cea40aa1409b899ab7">asio::deadline_timer::async_wait()</a> function to perform an asynchronous wait. When calling this function we pass the <code>print</code> callback handler that was defined above.<p>
<div class="fragment"><pre class="fragment">  t.async_wait(print);
</pre></div><p>
Finally, we must call the <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00140.html#50ae7753f2c851cd3e91724bbfc5b444">asio::io_service::run()</a> member function on the io_service object.<p>
The asio library provides a guarantee that callback handlers will <b>only</b> be called from threads that are currently calling <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00140.html#50ae7753f2c851cd3e91724bbfc5b444">asio::io_service::run()</a>. Therefore unless the <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00140.html#50ae7753f2c851cd3e91724bbfc5b444">asio::io_service::run()</a> function is called the callback for the asynchronous wait completion will never be invoked.<p>
The <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00140.html#50ae7753f2c851cd3e91724bbfc5b444">asio::io_service::run()</a> function will also continue to run while there is still "work" to do. In this example, the work is the asynchronous wait on the timer, so the call will not return until the timer has expired and the callback has completed.<p>
It is important to remember to give the io_service some work to do before calling <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00140.html#50ae7753f2c851cd3e91724bbfc5b444">asio::io_service::run()</a>. For example, if we had omitted the above call to <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00106.html#2ad7fdf0eb7a53cea40aa1409b899ab7">asio::deadline_timer::async_wait()</a>, the io_service would not have had any work to do, and consequently <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00140.html#50ae7753f2c851cd3e91724bbfc5b444">asio::io_service::run()</a> would have returned immediately.<p>
<div class="fragment"><pre class="fragment">  io.<a class="codeRef" doxygen="asio.doxytags:../reference/" href="../reference/a00140.html#50ae7753f2c851cd3e91724bbfc5b444">run</a>();

  <span class="keywordflow">return</span> 0;
}
</pre></div><p>
See the <a class="el" href="tuttimer2src.html">full source listing</a> <br>
 Return to the <a class="el" href="index.html#index">tutorial index</a> <br>
 Previous: <a class="el" href="tuttimer1.html">Timer.1 - Using a timer synchronously</a> <br>
 Next: <a class="el" href="tuttimer3.html">Timer.3 - Binding arguments to a handler</a>     <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.7</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
  </BODY>
</HTML>
