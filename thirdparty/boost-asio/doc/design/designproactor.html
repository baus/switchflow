<HTML>
  <HEAD>
    <TITLE>asio Design: Proactor</TITLE>
    <LINK HREF="asio.css" REL="stylesheet" TYPE="text/css">
    <LINK HREF="tabs.css" REL="stylesheet" TYPE="text/css">
  </HEAD>
  <BODY BGCOLOR="#FFFFFF">
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.7</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>Design</B>
          </TD>
        </TR>
      </TABLE>
    </DIV>
<!-- Generated by Doxygen 1.4.7 -->
<h1><a class="anchor" name="designproactor">Proactor</a></h1>The asio library is based on the Proactor pattern [1]. This design note describes how asio implements this design pattern, and outlines the advantages and disadvantages of this approach.<h2><a class="anchor" name="designproactoroverview">
Overview</a></h2>
First, let us examine how the Proactor design pattern is implemented in asio, without reference to platform-specific details.<p>
<img src="proactor.dot.png" alt="proactor.dot" border="0" usemap="#proactor.dot.map">
<map name="proactor.dot.map"></map>
<div align="center">
<p><strong>Proactor design pattern (adapted from [1])</strong></p>
</div>
 <dl compact><dt><b>Asynchronous Operation</b></dt><dd>Defines an operation that is executed asynchronously, such as an asynchronous read or write on a socket.</dd></dl>
<dl compact><dt><b>Asynchronous Operation Processor</b></dt><dd>Executes asynchronous operations and queues events on a completion event queue when operations complete. From a high-level point of view, services like <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00164.html">asio::stream_socket_service</a> are asynchronous operation processors.</dd></dl>
<dl compact><dt><b>Completion Event Queue</b></dt><dd>Buffers completion events until they are dequeued by an asynchronous event demultiplexer.</dd></dl>
<dl compact><dt><b>Completion Handler</b></dt><dd>Processes the result of an asynchronous operation. These are function objects, often created using <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/boost_bind.html">boost::bind</a>.</dd></dl>
<dl compact><dt><b>Asynchronous Event Demultiplexer</b></dt><dd>Blocks waiting for events to occur on the completion event queue, and returns a completed event to its caller.</dd></dl>
<dl compact><dt><b>Proactor</b></dt><dd>Calls the asynchronous event demultiplexer to dequeue events, and dispatches the completion handler (i.e. invokes the function object) associated with the event. This abstraction is represented by <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00140.html">asio::io_service</a>.</dd></dl>
<dl compact><dt><b>Initiator</b></dt><dd>Application-specific code that starts asynchronous operations. The initiator interacts with an asynchronous operation processor via a high-level interface such as asio::stream_socket, which in turn delegates to a service like <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00164.html">asio::stream_socket_service</a>.</dd></dl>
<h2><a class="anchor" name="designproactorposix">
Implementation using reactor</a></h2>
On many platforms, asio implements the Proactor design pattern in terms of a Reactor, such as <code>select</code>, <code>epoll</code> or <code>kqueue</code>. This implementation approach corresponds to the Proactor design pattern as follows:<p>
<dl compact><dt><b>Asynchronous Operation Processor</b></dt><dd>A reactor implemented using <code>select</code>, <code>epoll</code> or <code>kqueue</code>. When the reactor indicates that the resource is ready to perform the operation, the processor executes the asynchronous operation and enqueues the associated completion handler on the completion event queue.</dd></dl>
<dl compact><dt><b>Completion Event Queue</b></dt><dd>A linked list of completion handlers (i.e. function objects).</dd></dl>
<dl compact><dt><b>Asynchronous Event Demultiplexer</b></dt><dd>This is implemented by waiting on an event or condition variable until a completion handler is available in the completion event queue.</dd></dl>
<h2><a class="anchor" name="designproactorwin">
Implementation using Windows overlapped I/O</a></h2>
On Windows NT, 2000 and XP, asio takes advantage of overlapped I/O to provide an efficient implementation of the Proactor design pattern. This implementation approach corresponds to the Proactor design pattern as follows:<p>
<dl compact><dt><b>Asynchronous Operation Processor</b></dt><dd>This is implemented by the operating system. Operations are initiated by calling an overlapped function such as <code>AcceptEx</code>.</dd></dl>
<dl compact><dt><b>Completion Event Queue</b></dt><dd>This is implemented by the operating system, and is associated with an I/O completion port. There is one I/O completion port for each <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00140.html">asio::io_service</a> instance.</dd></dl>
<dl compact><dt><b>Asynchronous Event Demultiplexer</b></dt><dd>Called by asio to dequeue events and their associated completion handlers.</dd></dl>
<h2><a class="anchor" name="designproactoradv">
Advantages</a></h2>
<dl compact><dt><b>Portability</b></dt><dd></dd></dl>
The library interface can be reused independently of the operating system's underlying demultiplexing mechanism [1]. The Proactor interface may be implemented using a range of event sources, including the synchronous event demultiplexers that typify the Reactor pattern, such as select.<p>
<dl compact><dt><b>Decoupling threading from concurrency</b></dt><dd></dd></dl>
Long-duration operations are performed asynchronously by the Proactor on behalf of the application. Consequently applications do not need to spawn many threads in order to increase concurrency [1].<p>
<dl compact><dt><b>Performance</b></dt><dd></dd></dl>
Implementation strategies such as thread-per-connection can degrade system performance, due to increased context switching, synchronization and data movement among CPUs [1]. The Proactor pattern can avoid the cost of context switching by minimising the number of operating system threads, and only activating the logical threads of control that have events to process.<p>
<dl compact><dt><b>Simplified application synchronisation</b></dt><dd></dd></dl>
Asynchronous operation completion handlers can be written as though they exist in a single-threaded environment, and so application logic can be developed with little or no concern for synchronisation issues [1].<p>
<dl compact><dt><b>Function composition</b></dt><dd></dd></dl>
Function composition refers to the implementation of functions to provide a higher-level operation, such as sending a message in a particular format. Each function is implemented in terms of multiple calls to lower-level read or write operations.<p>
For example, consider a protocol where each message consists of a fixed-length header followed by a variable length body, where the length of the body is specified in the header. A hypothetical read_message operation could be implemented using two lower-level reads, the first to receive the header and, once the length is known, the second to receive the body.<p>
To compose functions in a Proactor model, asynchronous operations can be chained together. That is, a completion handler for one operation can initiate the next. Starting the first call in the chain can be encapsulated so that the caller need not be aware that the higher-level operation is implemented as a chain of asynchronous operations.<p>
The ability to compose new operations in this way simplifies the development of higher levels of abstraction above a networking library, such as functions to support a specific protocol.<h2><a class="anchor" name="designproactordisadv">
Disadvantages</a></h2>
<dl compact><dt><b>Program complexity</b></dt><dd></dd></dl>
It is more difficult to develop applications using asynchronous mechanisms due to the separation in time and space between operation initiation and completion [1]. Applications may also be harder to debug due to the inverted flow of control.<p>
<dl compact><dt><b>Memory usage</b></dt><dd></dd></dl>
Buffer space must be committed for the duration of a read or write operation, which may continue indefinitely, and a separate buffer is required for each concurrent operation. The Reactor pattern, on the other hand, does not require buffer space until a socket is ready for reading or writing.<h2><a class="anchor" name="designproactorrefs">
References</a></h2>
[1] D. Schmidt et al, <em>Pattern Oriented Software Architecture, Volume 2</em>. Wiley, 2000.     <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.7</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
  </BODY>
</HTML>
