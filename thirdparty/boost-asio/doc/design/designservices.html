<HTML>
  <HEAD>
    <TITLE>asio Design: Services</TITLE>
    <LINK HREF="asio.css" REL="stylesheet" TYPE="text/css">
    <LINK HREF="tabs.css" REL="stylesheet" TYPE="text/css">
  </HEAD>
  <BODY BGCOLOR="#FFFFFF">
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.7</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>Design</B>
          </TD>
        </TR>
      </TABLE>
    </DIV>
<!-- Generated by Doxygen 1.4.7 -->
<h1><a class="anchor" name="designservices">Services</a></h1>The abstractions asio publishes for sockets (and other resources) are divided into three parts:<p>
<ul>
<li>A service that provides a wrapper around a platform's implementation of the resource:</li>
</ul>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Allocator = std::allocator&lt;<span class="keywordtype">void</span>&gt; &gt;
<span class="keyword">class </span>stream_socket_service
{
<span class="keyword">public</span>:
  <span class="comment">// ...</span>

  <span class="keyword">typedef</span> implementation_defined impl_type;

  <span class="comment">// ...</span>

  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;
  <span class="keywordtype">void</span> async_receive(impl_type&amp; impl, <span class="keywordtype">void</span>* data, size_t max_length,
      socket_base::message_flags flags, Handler handler);

  <span class="comment">// ...</span>
};
</pre></div><p>
<ul>
<li>A class template providing an object-oriented interface, where the template parameter is the service:</li>
</ul>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Service&gt;
<span class="keyword">class </span>basic_stream_socket
{
<span class="keyword">public</span>:
  <span class="keyword">typedef</span> Service service_type;
  <span class="keyword">typedef</span> <span class="keyword">typename</span> service_type::impl_type impl_type;

  <span class="comment">// ...</span>

  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;
  <span class="keywordtype">void</span> async_receive(<span class="keywordtype">void</span>* data, size_t max_length,
      socket_base::message_flags flags, Handler handler)
  {
    service_.async_receive(impl_, data, max_length, flags, handler);
  }

  <span class="comment">// ...</span>

<span class="keyword">private</span>:
  service_type&amp; service_;
  impl_type impl_;
};
</pre></div><p>
<ul>
<li>A typedef for the typical usage:</li>
</ul>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> basic_stream_socket&lt;stream_socket_service&lt;&gt; &gt; stream_socket;
</pre></div><p>
This design attempts meet the following goals:<p>
<ul>
<li>To efficiently encapsulate the operating system's interface for the corresponding resource. On most operating systems a socket is represented by an integer, and so the service class wraps that facility portably and without adding a "heavyweight" class around it.</li>
</ul>
<ul>
<li>To allow the implementation of the socket to be customised. Some developers may need to use a different allocator, or perhaps a completely different implementation for sockets. This can be done by supplying a different argument to the basic_stream_socket template.</li>
</ul>
<ul>
<li>To make the most common usage appear no different to a class (in a similar fashion to std::string vs std::basic_string).</li>
</ul>
<h2><a class="anchor" name="designservicesandioservice">
Services and the Demuxer</a></h2>
The <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00140.html">asio::io_service</a> object acts as an extensible collection of services, not dissimilar to the way a std::locale object is composed of facets. The io_service contains one service object for each service type, and the service objects are accessed by their types (see asio::basic_io_service::get_service).<p>
However, unlike std::locale, services are loaded by the io_service only when first used. This means that you do not pay for the resources associated with a service unless you instantiate the corresponding class. For example, the deadline_timer_service implementation for Win32 uses a background thread, but this thread will not be created if there are no deadline_timer objects in a program.<p>
This design also allows the io_service to be extended by user-defined services. As an example, a user may want to simulate asynchronous database access using a pool of background threads. A database_connection_service class can be defined to create and manage the thread pool, and each database_connection object uses this service.     <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.7</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
  </BODY>
</HTML>
